Treatment of inhomogeneous constraints

In case some constraint lines have inhomogeneities (which is typically the case if the constraint comes from implementation of inhomogeneous boundary conditions), the situation is a bit more complicated than if the only constraints were due to hanging nodes alone. This is because the elimination of the non-diagonal values in the matrix generate contributions in the eliminated rows in the vector. This means that inhomogeneities can only be handled with functions that act simultaneously on a matrix and a vector. This means that all inhomogeneities are ignored in case the respective condense function is called without any matrix (or if the matrix has already been condensed before).

The use of the AffineConstraints class for implementing Dirichlet boundary conditions is discussed in the step-22 tutorial program. A further example that utilizes AffineConstraints is step-41. The situation here is little more complicated, because there we have some constraints which are not at the boundary. There are two ways to apply inhomogeneous constraints after creating an AffineConstraints object:

First approach:

    Apply the AffineConstraints::distribute_local_to_global() function to the system matrix and the right-hand-side with the parameter use_inhomogeneities_for_rhs = false (i.e., the default)
    Set the solution to zero in the inhomogeneous constrained components using the AffineConstraints::set_zero() function (or start with a solution vector equal to zero)
    solve() the linear system
    Apply AffineConstraints::distribute() to the solution

Second approach:

    Use the AffineConstraints::distribute_local_to_global() function with the parameter use_inhomogeneities_for_rhs = true and apply it to the system matrix and the right-hand-side
    Set the concerning components of the solution to the inhomogeneous constrained values (for example using AffineConstraints::distribute())
    solve() the linear system
    Depending on the solver now you have to apply the AffineConstraints::distribute() function to the solution, because the solver could change the constrained values in the solution. For a Krylov based solver this should not be strictly necessary, but it is still possible that there is a difference between the inhomogeneous value and the solution value in the order of machine precision, and you may want to call AffineConstraints::distribute() anyway if you have additional constraints such as from hanging nodes.

Of course, both approaches lead to the same final answer but in different ways. Using the first approach (i.e., when using use_inhomogeneities_for_rhs = false in AffineConstraints::distribute_local_to_global()), the linear system we build has zero entries in the right hand side in all those places where a degree of freedom is constrained, and some positive value on the matrix diagonal of these lines. Consequently, the solution vector of the linear system will have a zero value for inhomogeneously constrained degrees of freedom and we need to call AffineConstraints::distribute() to give these degrees of freedom their correct nonzero values.

On the other hand, in the second approach, the matrix diagonal element and corresponding right hand side entry for inhomogeneously constrained degrees of freedom are so that the solution of the linear system already has the correct value (e.g., if the constraint is that x13=42 then row 13 if the matrix is empty with the exception of the diagonal entry, and b13/A13,13=42 so that the solution of Ax=b must satisfy x13=42 as desired). As a consequence, we do not need to call AffineConstraints::distribute() after solving to fix up inhomogeneously constrained components of the solution, though there is also no harm in doing so.

There remains the question of which of the approaches to take and why we need to set to zero the values of the solution vector in the first approach. The answer to both questions has to do with how iterative solvers solve the linear system. To this end, consider that we typically stop iterations when the residual has dropped below a certain fraction of the norm of the right hand side, or, alternatively, a certain fraction of the norm of the initial residual. Now consider this:

    In the first approach, the right hand side entries for constrained degrees of freedom are zero, i.e., the norm of the right hand side really only consists of those parts that we care about. On the other hand, if we start with a solution vector that is not zero in constrained entries, then the initial residual is very large because the value that is currently in the solution vector does not match the solution of the linear system (which is zero in these components). Thus, if we stop iterations once we have reduced the initial residual by a certain factor, we may reach the threshold after a single iteration because constrained degrees of freedom are resolved by iterative solvers in just one iteration. If the initial residual was dominated by these degrees of freedom, then we see a steep reduction in the first step although we did not really make much progress on the remainder of the linear system in this just one iteration. We can avoid this problem by either stopping iterations once the norm of the residual reaches a certain fraction of the norm of the right hand side, or we can set the solution components to zero (thus reducing the initial residual) and iterating until we hit a certain fraction of the norm of the initial residual.
    In the second approach, we get the same problem if the starting vector in the iteration is zero, since then the residual may be dominated by constrained degrees of freedom having values that do not match the values we want for them at the solution. We can again circumvent this problem by setting the corresponding elements of the solution vector to their correct values, by calling AffineConstraints::distribute() before solving the linear system (and then, as necessary, a second time after solving).

In addition to these considerations, consider the case where we have inhomogeneous constraints of the kind x3=12x1+12, e.g., from a hanging node constraint of the form x3=12(x1+x2) where x2 is itself constrained by boundary values to x2=1. In this case, the AffineConstraints container can of course not figure out what the final value of x3 should be and, consequently, can not set the solution vector's third component correctly. Thus, the second approach will not work and you should take the first.